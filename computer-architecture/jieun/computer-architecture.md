# 1. 컴퓨터의 기본 구조
## 1.1. 폰 노이만 구조 (Von Neumann Architecture)
예전에는 연산을 바꿀 때마다 전선의 위치를 바꿔가며 프로그래밍을 수행해야 하는 번거로움이 있었고 시간도 많이 소요됐다. 이런 단점을 해결하기 위한 새로운 아키텍처가 폰 노이만 구조이다.


프로그램(명령어)과 데이터를 Memory에 보관하고, CPU는 메모리에서 저장된 명령어를 꺼내서 지시대로 연산을 수행한다.
오늘날의 모든 컴퓨터 구조가 이런 구조를 따르고 있다.

### 1.1.1. 폰 노이만의 한계
폰 노이만 구조에서는 CPU와 메모리가 단일 버스를 통해 연결된다. 이때 명령어와 데이터가 같은 경로를 사용해 CPU와 메모리 사이를 오가는 과정에서 데이터 전송 속도가 제한되어 병목 현상(Bottleneck)이 발생한다.

## 1.2. 시스템 버스
컴퓨터의 구성요소 간의 데이터 및 신호 교환을 위한 통로

#### 데이터 버스
- 데이터가 이동하는 통로
- 양방향 버스

#### 주소 버스
- 기억 장치의 주소 또는 I/O 장치의 포트 번호가 이동하는 통로
- 단방향 버스(CPU가 주소를 정하기 때문)

#### 제어 버스
- CPU에서 발생하는 제어 명령이나 상태 신호가 이동하는 통로
- 양방향 버스

## 1.3. 명령어 사이클
인출(Fetch) → 해독(Decode) → 실행(Execute) → 저장(Store) 순으로 진행된다.

1) Fetch: 메모리 주소에서 명령어 가져오기
2) Decode: 명령어 해석
3) Execute: 해석한 명령어 실행
4) Store: 실행 결과가 필요에 따라 메모리에 저장

# 2. CPU
중앙처리장치(Central Processing Unit, CPU)
주 기억장치인 Memory에서 명령어를 읽어 들이고 이를 해석하여 수행하는 작업을 한다.

## 2.1. CPU의 구성 요소

#### ALU(Arithmetic Unit)
- 산술 및 논리 연산을 수행한다.
- 레지스터로부터 피연산자를 받고, 연산 결과를 다시 레지스터로 보낸다.

#### Control Unit
- 메모리에서 명령어를 읽고 해석하여 제어 신호를 생성하는 장치

#### Register
- 고속 기억장치로, 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장한다.
  - 범용 레지스터: 연산에 필요한 데이터나 연산 결과를 임시로 저장
  - 특수목적 레지스터: 특별한 용도로 사용하는 레지스터
    - MAR(메모리 주소 레지스터): 읽기와 쓰기 연산을 수행할 주기억장치 주소 저장
    - PC(프로그램 카운터): 다음에 수행할 명령어 주소 저장
    - IR(명령어 레지스터): 현재 실행 중인 명령어 저장
    - MBR(메모리 버퍼 레지스터): 주기억장치에서 읽어온 데이터 또는 저장할 데이터 임시 저장
    - AC(누산기): 연산 결과 임시 저장

## 2.2. CPU의 연산 과정
Fetch - Decode - Execute - Writeback 으로 총 4단계로 이루어진다.

1) Fetch(인출): 메모리상의 PC가 가리키는 명령어를 CPU로 인출하여 Reg에 적재
2) Decode(해석): 명령어의 해석, 명령어의 종류와 타겟 등을 판단
3) Execute(실행): 해석된 명령어에 따라 데이터에 대한 연산 수행
4) Writeback(쓰기): 명령어대로 처리 완료된 데이터를 메모리에 기록

## 2.3. 명령어 처리 방식
ISA(Instruction Set Architecture)는 CPU가 인식, 해석, 실행할 수 있는 명령어들의 모음이다. CPU가 작동하려면 프로그램이 있어야 하고 명령어를 주입해서 설계를 한다.
ISA를 설계하고 구현하는데 있어서 대표적인 두 가지 컴퓨터 아키텍처가 CISC와 RISC이다.

### 2.3.1. CISC / RISC
|CISC|RISC|
|:----:|:----:|
|복잡하고 다양한 명령어|단순하고 적은 명령어|
|가변 길이 명령어|고정 길이 명령어|
|다양한 주소 지정 방식|적은 주소 지정 방식|
|실행되는 명령어 수가 적음|실행되는 명령어 수가 많음|
|파이프라이닝 어려움|파이프라이닝 쉬움|
|적은 레지스터 필요|많은 레지스터 필요|
|느린 처리속도|빠른 처리속도|
|많은 전력 소모|적은 전력 소모|
|복잡한 하드웨어 구조|단순한 하드웨어 구조|
|대표적으로 x86|대표적으로 ARM|

## 2.4. 파이프라인 해저드(Pipeline Hazard)
#### 파이프라이닝이란?
프로세서의 성능을 높이기 위해, 프로세서 내부에서 동시에 여러 명령어들을 다른 단계에서 처리할 수 있도록 하는 것이다. 
동시에 여러 개의 명령어를 처리함으로써 처리량을 올리는 것이 핵심이다.

#### 파이프라인 해저드란?
CPU가 파이프라이닝으로 병렬적으로 처리하게 될 때 다음 명령어가 다음 clock cycle에서 실행될 수 없는 상황이다.

#### 1) 구조적 해저드(Structure Hazard)
- 원인: 자원은 하나인데 여러 명령이 동시에 수행되려고 할 때 발생
- 해결: 하드웨어를 추가/업그레이드

#### 2) 데이터 해저드(Data Hazard)
- 원인: 데이터 의존성 문제, 앞선 명령어의 결과를 후속 명령어가 필요로 할 때, 앞선 명령어가 처리될 때까지 후속 명령어는 처리되지 못하고 기다리게 되면서 발생
- 해결: 지연(Stall), Data Forwarding

#### 3) 제어 해저드(Control Hazard)
- 원인: 프로그램이 근본적으로 갖는 의존성의 문제, 분기 명령어 실행으로 인해 발생
- 해결: Stall, 분기 예측 

# 3. 기억장치 계층 구조(Memory Hierarchy)

메모리 계층이란 필요에 따라 여러가지 종류로 나눈 것으로 레지스터, 캐시, 메모리(RAM), 하드디스크(저장장치)로 구성되어 있다.

#### 레지스터
- CPU 내부의 작은 메모리
-  휘발성이며 속도가 가장 빠르고, 기억 용량이 가장 적다.
#### 캐시
- L1, L2, L3 캐시를 지칭
- 휘발성이며, 속도가 빠르나 기억 용량이 적다.
#### 주기억장치(메모리)
- RAM
- 휘발성이며, 속도와 기억 용량은 보통이다.
#### 보조기억장치(디스크)
- HDD, SSD
- 비휘발성이며, 속도가 느리며 기억 용량이 많다.

* * *
#### 폰 노이만 구조
https://adeuran.tistory.com/20   
https://jerrycodezzz.tistory.com/94   
https://jiwondev.tistory.com/109   

#### 시스템 버스
https://youngkdevlog.tistory.com/62   
https://dheldh77.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4System-bus   

#### 명령어 사이클
https://maloveforme.tistory.com/155   

#### CPU
https://jtm0609.tistory.com/166   
https://rangvest.tistory.com/entry/CPU%EC%9D%98-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%9B%90%EB%A6%AC-CPU%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83   
https://velog.io/@cozyhama/CISC-VS-RISC-x86-VS-ARM   
https://devyonghee.github.io/theory/2022/09/27/CISC-RISC/   

#### 파이프라인 해저드
https://yesdohyun.tistory.com/79   
https://80000coding.oopy.io/e20ff4ae-ee5a-40dc-9c23-13a369e296d6   

